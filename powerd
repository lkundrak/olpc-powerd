#!/bin/sh


# the inputs that contribute to power management are:
#   switches (which appear as events on /dev/input/event[012]:
#       power button
#       ebook
#       lid
#   (it's unfortunate that these have no corresponding /sys state indicators)
#
#   conditions:
#       AC input (boolean)
#       battery level (numeric)
#   (it's unfortunate that these have no corresponding events)
#
#   wakeups
#       ac_power
#       battery_error
#       battery_soc
#       battery_state
#       ebook_mode_change
#       ps2event
#       wlan
#
#   user activity/idleness
#
#   other system activity (cpu load, network load, etc)


RUNDIR=/var/run

PROJECTDIR=/home/olpc/src/powerd
IMAGES=$PROJECTDIR
LOGFILE=$PROJECTDIR/powerd.log

FIFO=$RUNDIR/powerevents

# i'd use /sys/.../capacity_level here, but we never hit "critical" --
# we only get to "low", which then lasts for another half hour.
# using /sys/.../capacity (which gives a percentage), and cutting
# off at 5% means we're shutting down with (on my machine and
# battery under 2 minutes of runtime left.  close enough for jazz...
CAPACITY=/sys/class/power_supply/olpc-battery/capacity
AC_ONLINE=/sys/class/power_supply/olpc-ac/online  # 1 / 0
WAKEUP_EVENTS=/sys/power/wakeup_events
WAKEUP_SOURCE=/sys/power/wakeup-source

CONFIGFILE=/etc/powerd.conf
CONFIGFILE=$PROJECTDIR/powerd.conf

USER_ACTIVITY=/var/run/olpc-kbdshim_activity

BRIGHTNESS=/sys/class/backlight/dcon-bl/brightness
WLAN_ENABLED=/sys/power/wlan-enabled

set -u


yes_or_true()
{
    test "$1" || return 1

    case $1 in
    [yYtT]*) return 0 ;;
    *)     return 1 ;;
    esac
}

splash()
{
    case $1 in
    confirm)
        args="$PROJECTDIR/pleaseconfirm.pgm $PROJECTDIR/shuttingdown.pgm"
        ;;
    critical)
        args=$PROJECTDIR/shuttingdown.pgm
        ;;
    esac

    $PROJECTDIR/pnmto565 -s 9999999 -c -f $args &
    splashpid=$!
}

nextsplash()
{
    # kill -INT will cause pnmto565 to display next image
    test "${splashpid:-}" && kill -USR1 $splashpid
}

unsplash()
{
    # kill -INT will cause pnmto565 to restore original VT
    test "${splashpid:-}" && kill -INT $splashpid
    splashpid=;
}

leavesplash()
{
    # kill -TERM will cause pnmto565 to just die
    test "${splashpid:-}" && kill -TERM $splashpid
    splashpid=;
}

do_shutdown()
{
    # echo would shutdown -h now
    /sbin/shutdown -h now
}

check_battery()
{
    read capacity < $CAPACITY
    case $capacity in
    [54321])
        splash critical
        do_shutdown
        ;;
    esac
}

cpu_activity()
{
    return 0
}

network_activity()
{
    return 0
}

laptop_idle()
{
    if ! cpu_activity && ! network_activity
    then
        catnap
    fi
}

set_wlan_power()
{
    # very important not to do extra writes to wlan-enabled --
    # the node is sort of misnamed.  writing a 0 puts the
    # wlan into reset.  writing a 1 puts it into reset, and
    # immediately releases the reset.  so a reset is always
    # involved, even if brief.
    read_wlan_power w
    if [ "$w" != "$1" ]
    then
        test "$w" = 1 && echo WARNING:  blipping wlan-reset
        echo $1 > $WLAN_ENABLED
    fi
}

read_wlan_power()
{
    local x
    read x < $WLAN_ENABLED
    eval $1=\"$x\"
}

slumber()
{
    set_wakeupevents none
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WAN" || set_wlan_power 0
    echo 1   >/sys/devices/platform/dcon/sleep 
    echo mem >/sys/power/state
    #read wakeupsource < $WAKEUP_SOURCE
    #: wakeupsource from slumber is $wakeupsource
    #date >&2
    selfinject useractive2
    set_wakeupevents all
    echo 0   >/sys/devices/platform/dcon/sleep 
    set_wlan_power $wlp
    unsplash
    reevaluate
    set_idletimes
}

set_wakeupevents()
{
    case $1 in
    # setting "all" to 1/0 sets/clears everything else at once,
    # i.e.,  ac_power battery_error battery_soc battery_state 
    #       ebook_mode_change ps2event wlan"
    all)
        echo 1 >$WAKEUP_EVENTS/all
        echo 0 >$WAKEUP_EVENTS/battery_soc
        echo 0 >$WAKEUP_EVENTS/battery_state
        echo 0 >$WAKEUP_EVENTS/ac_power
        ;;
    none)
        echo 0 >$WAKEUP_EVENTS/all
        ;;
    esac
}

read_wakeupsource()
{
    local x
    read x < $WAKEUP_SOURCE
    eval $1=\"$x\"
}

catnap()
{
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WAN" || set_wlan_power 0
    while :
    do
        echo mem >/sys/power/state
        read_wakeupsource wakeupsource
        : wakeupsource is $wakeupsource
        #date >&2
        case $wakeupsource in
        "power button")
            selfinject power $(date +%s)
            break
            ;;

        "wlan packet")
            if yes_or_true "$config_MESH_or_WAKE_ON_WAN"
            then
                selfinject useractive2
                break
            fi
            ;;
        *)   #"lid"|"empty sci"|"key press"|"ebook")
            selfinject useractive2
            break
            ;;
        esac
    done
    set_wlan_power $wlp
    set_idletimes
}

set_brightness()
{
    echo $1 >$BRIGHTNESS
}

read_brightness()
{
    local x
    read x < $BRIGHTNESS
    eval $1=\"$x\"
}

brightness_ramp()
{
    local i
    test $1 = $2 && return

    incr=1
    test $1 -gt $2 && incr=-1

    i=$1
    while :
    do
        let i=i+$incr
        set_brightness $i
        test $i = $2 && break
        usleep 20000
    done
}

backlight()
{
    case $1 in
    restore)
        if [ "$dimmed" -a "$savebright" ]
        then
            read_brightness curbright
            if [ $curbright -lt $savebright ]
            then
                # could ramp here, but it wastes time while
                # the user is starting to work again
                set_brightness $savebright
            fi
            dimmed=;
        fi
        ;;
    dim)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            if [ $savebright -gt $config_IDLEDIM ]
            then
                brightness_ramp $savebright $config_IDLEDIM
            fi
            dimmed=true
        fi
        ;;
    off)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            set_brightness 0
            dimmed=true
        fi
        ;;
    esac
}

default_config()
{
    config_EBOOK_IDLETIMES="10 15 240"
    config_IDLETIMES="120 130 240"
    config_IDLEDIM=5
    config_SOLAR=no
    config_ALWAYSON=no
    config_MESH_or_WAKE_ON_WAN=yes
} 

read_config()
{

    source $CONFIGFILE

}

check_acstate()
{
    read on_ac < $AC_ONLINE
    if [ "$on_ac" = 1 ]
    then
        savepower=;
        yes_or_true ${config_SOLAR} && savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    else
        savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    fi
}

set_idletimes()
{
    if [ "$am_ebook" ]
    then
            idletimes=${config_EBOOK_IDLETIMES}
    else
            idletimes=${config_IDLETIMES}
    fi
    if [ "${1:-}" != ifchanged -o "$idletimes" != "${last_idletimes}" ]
    then
        echo "I $idletimes" >/var/run/olpc-kbdshim_rotate
    fi
    last_idletimes="$idletimes"
}

reevaluate()
{
    check_acstate
}

selfinject()
{
    echo $* >$FIFO
}

sched_timer()
{
    (sleep $1; shift 1; selfinject timerdone $*) &
}


dcon_freeze()
{
    echo $1 > /sys/devices/platform/dcon/freeze
}

event_loop()
{
    local event arg1 arg2 more idletimes lastpowerpress timerseqno

    lastpowerpress=0;
    timerseqno=0;

    idletimes=${config_IDLETIMES:-"120 130 240"}

    set -x
    exec 2>>$LOGFILE
    : starting eventloop

    check_acstate
    set_idletimes

    trap "unsplash; exit" 1 2 3 15
    unsplash

    # recreate to flush, and to make sure it's a fifo
    rm -f $FIFO
    mkfifo $FIFO

    while :
    do
        set_idletimes ifchanged

        if ! read -t 10 event arg1 arg2 more
        then
            event=timeout
        fi

        : -------------------------
        : got $event arg1 ${arg1:-n/a}
        #date >&2

        case $event in

        power)
            am_idle=;
            now=$arg1
            if [ $(( $now - $lastpowerpress )) -ge 5 ]
            then # first press
                splash confirm
                set_idletimes   # reprime for "useractivity"
                let timerseqno=timerseqno+1
                sched_timer 6 $timerseqno gotosleep
                backlight restore
            else # second press
                nextsplash  # advance to next splash screen
                sleep 1
                do_shutdown &
                leavesplash # kill the splasher (leaving splash visible)
                sleep 9999999
            fi
            lastpowerpress=$now
            ;;

        timerdone)
            if [ "$timerseqno" = "$arg1" ]
            then
                echo $arg2 >$FIFO
            fi
            ;;

        lidclose|gotosleep)
            am_idle=;
            unsplash
            backlight off
            slumber
            ;;

        lidopen)
            am_idle=;
            unsplash
            backlight restore
            ;;

        ebookclose)
            am_idle=;
            am_ebook=true
            ;;

        ebookopen)
            am_idle=;
            am_ebook=;
            ;;

        useractive*)
            lastpowerpress=0  #invalidate outstanding power button timers
            let timerseqno=timerseqno+1  # as well as timerdone messages
            unsplash
            backlight restore
            am_idle=;
            test "$event" = useractive2 && set_idletimes
            ;;

        useridle1)
            am_idle=1
            if [ "$savepower" -a ! "$am_ebook" ]
            then
                backlight dim
            fi
            ;;

        useridle2)
            am_idle=2
            if [ "$savepower" ] && laptop_idle
            then
                catnap
            fi
            ;;

        useridle3)
            am_idle=3
            ;;

        timeout)
            osavepower=$savepower
            check_battery
            check_acstate
            if [ "$savepower" -a ! "$osavepower" ]
            then
                # this will force a restart of the timers,
                # so we'll go through the useridle1/2 cycle again
                set_idletimes
            fi
            ;;

        reconfig)
            read_config
            ;;

        esac
    done <> $FIFO
}


default_config
read_config
am_ebook=;
dimmed=;
savebright=;
last_idletimes=;

set_wakeupevents all

event_loop

