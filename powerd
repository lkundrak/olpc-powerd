#!/bin/sh
#
# powerd -- experimental power management for the XO
# 
# this daemon is a more transparent and flexible (if
# incompatible, and perhaps less robust!) replacement for ohmd on
# the XO.  powerd is independent of X, dbus, and hald, and so
# might be attractive to very lightweight software distributions.
#
# in addition to "standard" XO/ohmd functionality, powerd adds:
# -- a power button splash screen (allowing cancel, suspend, or shutdown).
# -- the ability to run arbitrary scripts after a resume.
# -- configurable timeouts until screen dim and sleep, and configurable
#    dim level.
# -- idle screen blanking after laptop has slept
# -- idle shutdown after laptop has slept
# -- low battery shutdown (only when not sleeping)
# -- different power management behavior when on wall power vs. battery.
# -- different behavior when in ebook mode
# -- ease of customization, given that its written in shell.
#
# unimplemented:
# -- inhibiting idle suspend based on system or network load.
# -- any special support for the mesh, whatsoever.
# -- there's some support for wake-on-lan, but it's not well tested.
# -- probably more.
#
# configuration:
#
# major config variables are documented below.  powerd reads
# its configuration from /etc/powerd/default once at startup,
# and again only when it receives a "reconfig" event on its
# event fifo (/var/run/powerevents).  the current configuration
# profile can be changed by sending "reconfig <profilename>" to
# the fifo.  folding the laptop into ebook mode will trigger an
# automatic profile switch to the "ebook" profile (if configured
# to do so with config_USE_EBOOK_PROFILE.)
#
# all times are expressed in seconds (though a UI could do whatever
# it wants, of course):
# the idle timers are "config_TIME_DIM", "config_TIME_SLEEP", and
# "config_TIME_BLANK".  dim must happen first.  sleep and
# blanking can happen in either order.  if sleep happens first,
# the screen will stay on while the rest of the system sleeps. 
# if blanking is scheduled first, the screen will go dark while
# the laptop remains otherwise fully active.  in either case,
# when the screen is dark and the laptop is sleeping, it's a
# "deep" sleep -- keystrokes will not wake it up, just as if the
# power button had been used.  shutdown, of course, happens last.
# the maximum time that any sleep will last before the laptop shuts
# down is given by "config_MAX_SLEEP".
#
# "config_IDLEDIM" is how dim will the screen go when the first
# timer fires.  (range 0-15.)  if set to 15, the screen will never
# dim.
#
# normally we try and save power when on battery, but not when on
# external power.  setting "config_SOLAR" (boolean) causes laptop
# to behave as if power were scarce in either case.
#
# "config_ALWAYSON" (boolean) will suppress any automatic sleeps,
# even on battery.  this overrides "config_SOLAR".  note that
# creating the file /var/run/inhibit-idle-suspend will do much
# the same thing, except that in that case the screen is still
# allowed to dim.
#
# "config_CONFIRM_SECONDS" determines how long the shutdown/suspend
# confirmation splash screen stays visible before the laptop
# automatically suspends.
#
# "config_MESH_or_WAKE_ON_WLAN" (boolean) allows wireless to
# continue operating when the laptop is sleeping.  note that the
# wireless configuration may allow shutting down the wireless
# entirely (e.g., with "echo 0>/sys/power/wlan-enabled"), which
# may override this setting.
#
# "config_USE_EBOOK_PROFILE" (boolean) tells powerd to switch to
# the configuration profile named "ebook" when the laptop is
# folded into ebook mode.
#
#
# idle suspend can be manually inhibited by creating the file
#    /var/run/inhibit-idle-suspend
#
# post-resume scripts can be put in /etc/powerd/postresume.d -- the
# scripts will be run in lexicographic order.  the scripts are run
# detached from powerd, so they won't impede its operation -- however,
# they should be kept as short as possible.
#
#
# the inputs that contribute to power management are:
#
# -- switches:
#       power button
#       ebook
#       lid
# actions on these switches appear as events on /dev/input/event[012]. 
# powerd relies on the companion program "olpc-switchd" to report
# these events via the /var/run/powerevents fifo it creates for the
# purpose.  it's unfortunate that these events have no corresponding
# /sys state indicators, since knowing the state of the lid (or of
# ebook mode) would be useful in the absence of events (at startup,
# for instance).
#
#
# -- conditions:
#       AC input (boolean)
#       battery capacity (numeric)
# it's unfortunate that these have no corresponding events.  because
# they don't, olpc-switchd also monitors these two nodes (under /sys)
# and synthesizes events to represent their transitions.
#
#
# -- wakeups:
#       ac_power
#       battery_error
#       battery_soc (i.e. "state of charge" --> capacity)
#       battery_state
#       ebook_mode_change
#       ps2event
#       wlan
#       lid (or sometimes "empty sci")
# when the system wakes from sleep, /sys/power/wakeup-source reports
# the cause.  lid reporting is not reliable -- sometimes "empty sci"
# is reported instead.  (i've not yet seen a case where "empty sci" is
# reported for lid close i'm not ruling it out.)
#
#
# -- user activity/idleness:
# powerd expects user activity and user idle events to be delivered via
# the olpc-kbdshim daemon, when invoked with "-A /var/run/powerevents".
# the possible events are:
#       useractivity
#       useridle1
#       useridle2
#       useridle3
#
# these events are used in the following ways:
#
#                  screen          cpu
#                  ------          ---
#     useridle1     dim            on
#     useridle2     dim            sleep
#     rtcwake1      off            sleep
#     rtcwake2           shutdown
#
# or, if $config_TIME_BLANK is less than $config_TIME_SLEEP, then
# this sequence, which is more like a "normal" laptop behaves:
#
#                  screen          cpu
#                  ------          ---
#     useridle1     dim            on
#     useridle2     off            on
#     useridle3     off            sleep
#     rtcwake2           shutdown
#
#
#
# -- other system activity (cpu load, network load, etc):
#       unimplemented
#
# note that X11 DPMS is neither consulted nor configured, and it
# may still blank the display after some period of inactivity. 
# (this won't happen, of course, unless the DPMS "standby" time
# is shorter than powerd's "config_TIME_SLEEP" time.  the affect
# of DPMS doing this will result in confusion, since when DPMS
# blanks the screen, powerd can't tell that it's been done. 
# i.e., a laptop with a screen blanked by DPMS may behave
# differently than one blanked by powerd.  so "xset -dpms" is
# recommended, preferably in olpc-session.
#
# my intention is that this be runnable with most any shell.  no
# bash-specific features were used, unless by accident.
#
# -----------------------------------------------
#
# Copyright (C) 2009, Paul G Fox
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
# USA.
#

PROJECTDIR=/etc/powerd
RUNPARTSDIR=/etc/powerd/postresume.d

CONFIGDIR=$PROJECTDIR/conf
CONFIGLINK=$CONFIGDIR/curconfig.link
LOGFILE=$PROJECTDIR/powerd.log   # only used for debug, currently

CONFIRMSPLASH=$PROJECTDIR/pleaseconfirm.pgm
SHUTSPLASH=$PROJECTDIR/shuttingdown.pgm
BATTSHUTSPLASH=$PROJECTDIR/shuttingdown.pgm

FIFO=/var/run/powerevents

# note re: battery capacity:
# i'd use /sys/.../capacity_level here, but we won't get
# "critical" -- the EC and kernel can only currently indicate
# "low", "normal", or "full", and "low" lasts for another half
# hour -- way too early for shutdown.  using /sys/.../capacity
# (which gives a percentage), and cutting off at 5% means we're
# shutting down with (on my machine and battery under 2 minutes
# of runtime left.  the right answer is to use battery voltage --
# however, we can't get woken for that.  so we fudge, and use
# a combination.
CAPACITY=/sys/class/power_supply/olpc-battery/capacity  # percentage
MICROVOLTS=/sys/class/power_supply/olpc-battery/voltage_avg  # microvolts

AC_ONLINE=/sys/class/power_supply/olpc-ac/online  # 1/0
BRIGHTNESS=/sys/class/backlight/dcon-bl/brightness  # 0-15
WLAN_ENABLED=/sys/power/wlan-enabled # 1/0 (see comment at set_wlan_power())

WAKEUP_EVENTS=/sys/power/wakeup_events # directory of mask bits
WAKEUP_SOURCE=/sys/power/wakeup-source # contains name of last wakeup source.

DCON_FREEZE=/sys/devices/platform/dcon/freeze
DCON_SLEEP=/sys/class/backlight/dcon-bl/device/sleep

# command fifo for olpc-kbdshim
USER_ACTIVITY_CMDS=/var/run/olpc-kbdshim_command


set -u

log()
{
    logger -t powerd -p daemon.info -- "$@"
    test "$tracing" && echo "$(date +'%F %T') $@" >>$LOGFILE
}

yes_or_true()
{
    case $1 in
    [yYtT]*) return 0 ;;
    esac

    return 1
}

splash()
{
    case $1 in
    confirm)
        args="$CONFIRMSPLASH $SHUTSPLASH"
        ;;
    critical)
        args="$BATTSHUTSPLASH"
        ;;
    esac

    pnmto565fb -d -s 9999999 $args &
    splashpid=$!
}

nextsplash()
{
    # kill -USR1 will cause pnmto565fb to display next image (stays alive)
    test "${splashpid:-}" && kill -USR1 $splashpid
}

unsplash()
{
    # kill -INT will cause pnmto565fb to restore original VT
    test "${splashpid:-}" && kill -INT $splashpid
    splashpid=;
}

leavesplash()
{
    # kill -TERM will cause pnmto565fb to just die
    test "${splashpid:-}" && kill -TERM $splashpid
    splashpid=;
}

do_shutdown()
{
    log shutting down due to $*
    leavesplash # kill the splasher (leaving splash visible)
    usleep 50000
    /sbin/shutdown -h now &
    sleep 9999999
}

cpu_busy()
{
    # TBD
    return 1
}

network_busy()
{
    # TBD
    return 1
}

laptop_idle()
{
    test -f /var/run/inhibit-idle-suspend && return 1
    cpu_busy && return 1
    network_busy && return 1
    return 0
}

set_wlan_power()
{
    # very important not to do extra writes to wlan-enabled -- the
    # node is sort of misnamed.  writing a 0 puts the wlan into reset. 
    # writing a 1 puts it into reset, but immediately releases the
    # reset.  so a reset is always involved, even if brief.
    read_wlan_power w
    if [ "$w" != "$1" ]
    then
        test "$w" = 1 && echo WARNING:  blipping wlan-reset
        echo $1 > $WLAN_ENABLED
    fi
}

read_wlan_power()
{
    local x
    read x < $WLAN_ENABLED
    eval $1=\"$x\"
}

runparts()
{
    rc_action=$1
    test $rc_action = "resume" || return

    rc_dir=$RUNPARTSDIR
    test -d $rc_dir || return

    cd $rc_dir

    for s in *[^~]
    do
        case $s in
        '*[^~]') return;;  # s is the literal pattern
        esac

        if [ -x $s ]; then
                echo "Running $s $rc_action" >&2
                ./$s $rc_action || echo "*** $s failed"
        elif [ -f $s ]; then
                echo "Skipping $s (disabled, not executable)" >&2
        else
                if [ -L $s ]; then
                        echo "Removing dangling symlink $s" >&2
                        rm $s
                else
                        echo "Skipping $s (not an executable file)" >&2
                fi
        fi
    done

}

set_wakeupevents()
{
    # setting "all" to 1/0 sets/clears everything else at once,
    # i.e.,  ac_power battery_error battery_soc battery_state 
    #       ebook_mode_change ps2event wlan"
    case $1 in
    all)        echo 1 >$WAKEUP_EVENTS/all ;;
    none)       echo 0 >$WAKEUP_EVENTS/all ;;
    ac)         echo 1 >$WAKEUP_EVENTS/ac_power ;;
    battery)    echo 1 >$WAKEUP_EVENTS/battery_soc ;;
    esac
}

read_wakeupsource()
{
    local x
    read x < $WAKEUP_SOURCE
    eval $1=\"$x\"
}

snooze()
{
    runparts suspend
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WLAN" || set_wlan_power 0

    # we only use rtc alarms to either a) turn of the screen when
    # we've been sleeping for a while, or b) shutdown after we've been
    # sleeping for a while.  if we do a), we'll do b) next.
    rtctype=$1   # "until_screenoff", or "until_shutdown"
    orig_rtctime=$2
    rtctime=$orig_rtctime
    shutdowntime=${3:-}

    while :
    do
        sleep_started=$(date +%s);
        if [ $rtctype = until_shutdown ]
        then
            # if we're waiting for a shutdown, then this is a
            # pretty sound sleep.
            set_wakeupevents none
            set_wakeupevents ac
            if [ ! "$ac_online" ]
            then
                if [ "$battery_capacity" -le 20 ]
                then
                    set_wakeupevents battery
                fi
            fi
            test "$tracing" && sleep 1
            rtcwake -m mem -a -s $rtctime
            set_wakeupevents all
        else
            # otherwise we want most anything to wake us.
            test "$tracing" && sleep 1
            rtcwake -m mem -a -s $rtctime
        fi

        # prepare for the default case of simply re-sleeping for
        # the remaining time.  may be overridden.
        rtctime=$(( rtctime - ( $(date +%s) - sleep_started ) ))
        rtctime=$(( (rtctime < 0) ? 0 : rtctime ))

        read_wakeupsource wakeupsource
        : wakeupsource is $wakeupsource
        case $wakeupsource in
        "power button")
            if [ $rtctype = until_shutdown ]
            then
                # this takes care of the "screen blanked but not sleeping"
                # case.  we only want the button to give the splash menu
                # when the screen was lit when it was pushed.
                selfinject fake_useractive
            else
                # we're waiting until_screenoff, so screen is still on
                selfinject fake_powerbutton
            fi
            break
            ;;

        "wlan packet")
            if yes_or_true "$config_MESH_or_WAKE_ON_WLAN"
            then
                selfinject fake_useractive
                break
            fi
            ;;

        "rtc alarm"|"ac power"|battery*)

            : rtctype-wakeupsource is $rtctype-$wakeupsource

            power_check

            case $rtctype-$wakeupsource in
            until_screenoff-rtc*)
                backlight off
                rtctype=until_shutdown
                orig_rtctime=$shutdowntime
                rtctime=$shutdowntime
                ;;

            until_shutdown-rtc*)
                if [ "$savepower" -a ! "$no_auto_shutdown_on_ac" ]
                then
                    do_shutdown "idle timeout"
                fi
                # if we didn't shut down, we'll sleep again for
                # the same time as before, before we check again.
                rtctime=$orig_rtctime
                log "found external power, sleeping instead of shutdown"
                ;;

            until_shutdown-ac*)
                # restart the shutdown timer.  the choice of sleep time
                # is kind of a guess, since we're not tracking how much
                # charging we're getting while plugged in.  so if we're
                # plugged in, we sleep forever, otherwise, we sleep (again)
                # for the original time.
                if [ "$ac_online" ]
                then
                    rtctime=999999999
                else
                    rtctime=$orig_rtctime
                fi
                ;;

            *-battery*)  # all we do is check level, above.
                ;;

            *) # it's a leftover (spurious?) rtc wakeup.  go back to sleep.
                ;;

            esac
            ;;

        *)   # "lid"|"empty sci"|"key press"|"ebook")
            selfinject fake_useractive
            break
            ;;
        esac
    done
    set_wlan_power $wlp
    reset_idlecounter
    runparts resume &
}

set_brightness()
{
    echo $1 >$BRIGHTNESS
}

read_brightness()
{
    local x
    read x < $BRIGHTNESS
    eval $1=\"$x\"
}

brightness_ramp()
{
    local i
    test $1 = $2 && return

    # ramp in either direction
    incr=1
    test $1 -gt $2 && incr=-1

    i=$1
    while :
    do
        : $((i += incr))
        set_brightness $i
        test $i = $2 && break
        usleep 25000
    done
}

backlight()
{
    case $1 in
    restore)
        dcon wake
        if [ "$dimmed" -a "$savebright" ]
        then
            read_brightness curbright
            if [ $curbright -lt $savebright ]
            then
                # could ramp here, but it wastes time while
                # the user is starting to work again
                set_brightness $savebright
            fi
            dimmed=;
        fi
        ;;
    dim)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            if [ $savebright -gt $config_IDLEDIM ]
            then
                brightness_ramp $savebright $config_IDLEDIM
            fi
            dimmed=true
        fi
        ;;
    off)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            dimmed=true
        fi
        set_brightness 0
        dcon sleep
        ;;

    is_off)
        read_brightness b
        test $b = 0
        return
        ;;
    esac
}

default_config()
{
    # give all config values defaults, so we'll
    # never find them unset
    config_TIME_DIM=120
    config_TIME_SLEEP=130
    config_TIME_BLANK=240
    config_MAX_SLEEP=3600
    config_IDLEDIM=5
    config_SOLAR=no
    config_ALWAYSON=no
    config_MESH_or_WAKE_ON_WLAN=yes
    config_CONFIRM_SECONDS=7
    config_USE_EBOOK_PROFILE=false
} 

read_config()
{
    if [ ! -r $CONFIGLINK ]
    then
        log cannot read configuration from $CONFIGLINK
        exit 1
    fi
    source $CONFIGLINK
    if yes_or_true $config_ALWAYSON
    then
        log configured for always on
    elif yes_or_true $config_SOLAR
    then
        log configured to save power even on external source
    else
        log configured for power saving on battery only
    fi
}

choose_config()
{
    newconfig=$1
    curconfig=$(readlink $CONFIGLINK)

    if [ ! "$newconfig" ]
    then
        log "(re)reading $curconfig"
        return 0
    fi

    if [ "$newconfig" = previous ]
    then
        if [ ! "$prevconfig" ]
        then
            return 1
        fi
        newconfig=$prevconfig
    fi

    if [ "$curconfig" = "$newconfig" ]
    then
        return 0
    fi

    if [ ! -e $CONFIGDIR/$newconfig ]
    then
        log request for nonexistent configuration \"$newconfig\"
        if [ ! -e $CONFIGDIR/default ]
        then
            return 1
        fi
        newconfig=default
    fi

    if [ "$newconfig" = ebook ]
    then
        prevconfig=$curconfig
    else
        prevconfig=;
    fi

    ln -sf $newconfig $CONFIGLINK
    log configuring from \"$newconfig\"

    return 0
}

evaluate_ac_state()
{
    if [ "$ac_online" ]
    then
        savepower=;
        yes_or_true ${config_SOLAR} && savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    else
        savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    fi
    # return success if on external power
    test "$ac_online"
}

check_acstate()
{
    read on_ac < $AC_ONLINE
    ac_online=;
    test "$on_ac" = 1 && ac_online=true

    evaluate_ac_state
}

o_maybe_battery_shutdown()  # old version, uses capacity only
{

    if [ ! "$ac_online" ]
    then
        case $battery_capacity in
        [54321])   # 5% or less
            splash critical
            sleep 1
            do_shutdown "low battery"
            ;;
        esac
    fi
}

maybe_battery_shutdown()
{

    test "$ac_online" && return

    case $battery_capacity in
    [987654321])
        read uvolts < $MICROVOLTS
        if [ $uvolts -le 5700000 ]  # EC's idea of critical voltage: 5.7V
        then
            splash critical
            sleep 1
            do_shutdown "low battery"
        fi
        ;;
    esac

}

read_battery()
{
    read battery_capacity < $CAPACITY
}

power_check()
{
    if ! check_acstate
    then
        read_battery
        maybe_battery_shutdown
    fi
}

reset_idlecounter()
{
    # olpc-kbdshim will reset its idle timers when the deadlines are reset
    echo "I $t1 $t2 $t3" >$USER_ACTIVITY_CMDS
}

set_idletimes()
{

    # have the values changed?
    idletimes="$config_TIME_DIM $config_TIME_SLEEP $config_TIME_BLANK"
    test "$idletimes" = "$last_idletimes" && return 1
    last_idletimes="$idletimes"

    # now validate the configured times, and turn them into deltas.

    # defaults:
    t1=${config_TIME_DIM:-120}
    t2=${config_TIME_SLEEP:-0}
    t3=${config_TIME_BLANK:-0}

    # force all to be numeric:
    test "$t1" -eq "$t1" || t1=120
    test "$t2" -eq "$t2" || t2=0
    test "$t3" -eq "$t3" || t3=0

    # adjust the ordering of blank/sleep:
    if [ "$t3" -ge "$t2" ]
    then
        dark_before_sleep=;
    else
        tt="$t2"; t2="$t3"; t3="$tt"
        dark_before_sleep=true
    fi

    #if any delta is 0 or negative, make it 60
    #if any delta is less than 5, make it at least 5
    test "$t2" -le "$t1"        && t2=$((t1 + 60))
    test "$t2" -le $((t1 + 5))  && t2=$((t1 + 5))

    test "$t3" -le "$t2"        && t3=$((t2 + 60))
    test "$t3" -le $((t2 + 5))  && t3=$((t2 + 5))

    # give olpc-kbdshim the timeouts
    echo "I $t1 $t2 $t3" >$USER_ACTIVITY_CMDS

    t4=${config_MAX_SLEEP:-0}
    test "$t4" -eq "$t4" || t4=0
    test "$t4" -le "5" && t4=300

    if [ "$dark_before_sleep" ]
    then
        screenofftimer=;
        shutdowntimer=$t4
        log dim in $t1 seconds, blank in $t2, sleep in $t3, shutdown in $t4
    else
        screenofftimer=$((t3 - t2))
        shutdowntimer=$t4
        log dim in $t1 seconds, sleep in $t2, blank in $t3, shutdown in $t4
    fi

    return 0
}

reevaluate()
{
    if [ "${1:-}" = all -o \
         "${o_savepower:-}" != "$savepower" -o \
         "${o_ebook:-}" != "$am_ebook" ]
    then
        set_idletimes || reset_idlecounter
    fi
    o_ebook=$am_ebook
    o_savepower=$savepower
}

selfinject()
{
    echo $* >$FIFO
}

sched_powertimer()
{
    # we can't cancel timers, so give them sequence numbers
    : $((timerseqno += 1))
    (sleep $1; shift 1; selfinject powertimerdone $timerseqno $*) &
}

sched_unfreezetimer()
{
    (sleep $1; selfinject unfreezetimerdone ) &
}

invalidate_powertimer()
{
    # bump the seq number so we won't match a scheduled timer
    # when it arrives.
    : $((timerseqno += 1))
}

dcon()
{
    case $1 in
    freeze) echo 1 > $DCON_FREEZE ;;
    thaw)   echo 0 > $DCON_FREEZE ;;
    sleep)  echo 1 > $DCON_SLEEP ;;
    wake)   echo 0 > $DCON_SLEEP ;;
    esac
}

gotactivity()
{
    invalidate_powertimer
    unsplash
}

event_loop()
{
    local event arg1 arg2 more

    : starting eventloop

    set_idletimes

    trap "unsplash; exit" 0 # 1 2 3 15
    unsplash

    # recreate to flush, and to make sure it's a fifo
    rm -f $FIFO
    mkfifo $FIFO

    while :
    do

        reevaluate

        arg1=; arg2=; more=;
        read event arg1 arg2 more

        : -------------------------
        : got "<$event>", arg1: ${arg1:-n/a} arg2: ${arg2:-n/a}

        case $event in

        powerbutton|fake_powerbutton)
            if backlight is_off
            then
                gotactivity
                backlight restore
                reset_idlecounter
            else
                if [ "$powerseqno" != "$timerseqno" ]
                then # first press
                    splash confirm
                    reset_idlecounter # reprime for "useractivity"
                    sched_powertimer $config_CONFIRM_SECONDS gotosleep
                    powerseqno=$timerseqno
                    backlight restore
                else # second press
                    nextsplash  # advance to next splash screen
                    sleep 1
                    do_shutdown  "power press"
                fi
            fi
            ;;

        powertimerdone)
            # are we still waiting for this timer?
            if [ "$timerseqno" = "$arg1" ]
            then
                echo $arg2 >$FIFO
                : $((timerseqno += 1))
            fi
            ;;

        lidclose|gotosleep)
            invalidate_powertimer
            backlight off
            # schedule a wakeup, so we can shut down
            snooze until_shutdown "$shutdowntimer"
            ;;

        lidopen)
            gotactivity
            backlight restore
            ;;

        ebookclose)  # i.e., fully flat in ebook mode
            am_ebook=true
            if yes_or_true $config_USE_EBOOK_PROFILE
            then
                choose_config ebook
            fi
            read_config
            reevaluate
            ;;

        ebookopen)
            am_ebook=;
            choose_config previous
            read_config
            reevaluate
            ;;

        useractive|fake_useractive)
            gotactivity
            backlight restore
            test "$event" = fake_useractive && reset_idlecounter
            ;;

        useridle1)
            if [ "$savepower" ]
            then
                backlight dim
            fi
            ;;

        useridle2)
            if [ "$savepower" ] && laptop_idle
            then
                if [ "$dark_before_sleep" ]
                then
                    backlight off
                else
                    snooze until_screenoff "$screenofftimer" "$shutdowntimer"
                fi
            fi
            ;;

        useridle3)
            if [ "$savepower" ] && laptop_idle
            then
                if [ "$dark_before_sleep" ]
                then
                    # schedule a wakeup, so we can shut down
                    snooze until_shutdown "$shutdowntimer"
                #else
                #    ; # shouldn't happen
                fi
            fi
            ;;

        ac)
            case $arg1 in
            online)  ac_online=true ;;
            *)       ac_online=; ;;
            esac
            evaluate_ac_state
            reevaluate
            ;;

        battery)
            battery_capacity=$arg1
            maybe_battery_shutdown
            ;;

        reconfig)
            choose_config ${arg1:-}
            read_config

            power_check

            reevaluate all
            ;;

        unfreezetimerdone)
            # this is a bit of a hack.  on the XO, the bootanim
            # script contrives to leave the dcon frozen at the end
            # of the init sequence.  it remains frozen until sugar
            # first becomes idle, at which point sugar sends a dbus
            # message to ohmd, causing ohmd to unfreeze the dcon.
            # since we don't do dbus, we unfreeze the dcon after 10
            # seconds.
            dcon thaw
            ;;

        trace-on)
            tracing on
            ;;
        trace-off)
            tracing off
            ;;
        esac

    done <> $FIFO
}

tracing()
{
    case $1 in
    on)
        exec 3>&2
        exec 2>>$LOGFILE
        set -x
        : tracing begun
        tracing=1
        ;;
    off)
        if [ "$tracing" ]
        then
            : tracing stopped
            set +x
            exec 2>&3
            tracing=;
        fi
        ;;
    esac
}

tracing=;

# uncomment for full tracing.
# (use powerd-control =tracing-on to enable at runtime.)
tracing on

am_ebook=;
o_ebook=xxx;
o_savepower=xxx;
dimmed=;
savebright=;
last_idletimes=;
timerseqno=1;
powerseqno=0;

# unimplemented
no_auto_shutdown_on_ac=;

sched_unfreezetimer 10

log starting

default_config
if [ ! -r $CONFIGLINK ]
then
    choose_config default
else
    log configuring from \"$(readlink $CONFIGLINK)\"
fi

read_config

power_check

reevaluate all


set_wakeupevents all

event_loop

