#!/bin/sh
#
# powerd -- experimental power management for the XO
# 
# this daemon is a more transparent and flexible (if
# incompatible, and perhaps less robust!) replacement for ohmd on
# the XO.  powerd is independent of X, dbus, and hald, and so
# might be attractive to very lightweight software distributions.
#
# in addition to "standard" XO/ohmd functionality, powerd adds:
# -- a power button splash screen (allowing cancel, suspend, or shutdown).
# -- the ability to run arbitrary scripts after a resume.
# -- configurable timeouts until screen dim and sleep, and configurable
#    dim level.
# -- different power management behavior when on wall power vs. battery.
# -- different behavior when in ebook mode (though detection may be unreliable)
# -- ease of customization, given that its written in shell.
#
# unimplemented:
# -- inhibiting idle suspend based on system or network load.
# -- any special support for the mesh, whatsoever.
# -- there's some support for wake-on-lan, but it's not well tested.
# -- probably more.
#
# major config variables are documented in powerd.conf.  powerd reads
# its configuration from /etc/powerd/powerd.conf once at startup,
# and again only when it receives a "reconfig" event on its
# event fifo (/var/run/powerevents).
#
# idle suspend can be manually inhibited by creating the file
#    /var/run/inhibit-idle-suspend
#
# post-resume scripts can be put in /etc/powerd/postresume.d -- the
# scripts will be run in lexicographic order.  the scripts are
# run detached from powerd, so they won't impede its operation -- however,
# they should be kept as short as possible.
#
# the inputs that contribute to power management are:
#
# ** switches:
#       power button
#       ebook
#       lid
# actions on these switches appear as events on
# /dev/input/event[012].  powerd relies on the companion
# program "olpc-switchd" to report these events via the
# /var/run/powerevents fifo it creates for the purpose.  it's
# unfortunate that these events have no corresponding /sys state
# indicators, since knowing the state of the lid, or of ebook
# mode, would be useful in the absence of events (at startup, for
# instance).  in addition, it seems that the ebook switch may
# suffer from the lid switch symptoms described in
# http://dev.laptop.org/ticket/5703 .  the lid switch events seem
# to be reliable (but see below re:  wakeup source reporting).
#
# ** conditions:
#       AC input (boolean)
#       battery level (numeric)
# it's unfortunate that these have no corresponding events, since
# otherwise no polling would be necessary.
#
# ** wakeups:
#       ac_power
#       battery_error
#       battery_soc
#       battery_state
#       ebook_mode_change
#       ps2event
#       wlan
#       lid (or sometimes "empty sci")
# when the system wakes from sleep, /sys/power/wakeup-source reports
# the cause.  lid reporting is not reliable -- sometimes "empty sci"
# is reported instead.  (i've not yet seen a case where "empty sci"
# is reported for lid close, or for ebook_mode_change, but i'm not
# ruling it out.)
#
# ** user activity/idleness:
#       useractivity
#       useridle1 (screen dims)
#       useridle2 (laptop sleeps)
#       useridle3 (currently unused, but if we could schedule a
#            wakeup from sleep, we could use this for an idle shutdown)
# powerd expects user activity and user idle events to be delivered via
# the olpc-kbdshim daemon, when invoked with "-A /var/run/powerevents"
#
# ** other system activity (cpu load, network load, etc):
#       unimplemented
#
# note that X11 DPMS is neither consulted nor configured, and it
# may still be used to blank the display after some period of
# inactivity.  (this won't happen, of course, unless the DPMS
# "standby" time is shorter than powerd's "useridle2" time.
#
# my intention is that this be runnable with most any shell.  no
# bash-specific features were used, unless by accident.
#
# -----------------------------------------------
#
# Copyright (C) 2009, Paul G Fox
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
# USA.
#

PROJECTDIR=/etc/powerd
RUNPARTSDIR=/etc/powerd/postresume.d

CONFIGFILE=$PROJECTDIR/powerd.conf
LOGFILE=$PROJECTDIR/powerd.log   # only used for debug, currently

CONFIRMSPLASH=$PROJECTDIR/pleaseconfirm.pgm
SHUTSPLASH=$PROJECTDIR/shuttingdown.pgm
BATTSHUTSPLASH=$PROJECTDIR/shuttingdown.pgm

FIFO=/var/run/powerevents

# note re: battery capacity:
# i'd use /sys/.../capacity_level here, but we never hit
# "critical" -- we only get to "low", which then lasts for
# another half hour.  using /sys/.../capacity (which gives a
# percentage), and cutting off at 5% means we're shutting down
# with (on my machine and battery under 2 minutes of runtime
# left.  close enough for jazz...
CAPACITY=/sys/class/power_supply/olpc-battery/capacity  # percentage

AC_ONLINE=/sys/class/power_supply/olpc-ac/online  # 1/0
BRIGHTNESS=/sys/class/backlight/dcon-bl/brightness  # 0-15
WLAN_ENABLED=/sys/power/wlan-enabled # 1/0 (see comment at set_wlan_power())

WAKEUP_EVENTS=/sys/power/wakeup_events # directory of mask bits
WAKEUP_SOURCE=/sys/power/wakeup-source # contains name of last wakeup source.

# command fifo for olpc-kbdshim
USER_ACTIVITY_CMDS=/var/run/olpc-kbdshim_command


set -u


yes_or_true()
{
    test "$1" || return 1

    case $1 in
    [yYtT]*) return 0 ;;
    *)     return 1 ;;
    esac
}

splash()
{
    case $1 in
    confirm)
        args="$CONFIRMSPLASH $SHUTSPLASH"
        ;;
    critical)
        args="$BATTSHUTSPLASH"
        ;;
    esac

    pnmto565fb -d -s 9999999 $args &
    splashpid=$!
}

nextsplash()
{
    # kill -USR1 will cause pnmto565fb to display next image
    test "${splashpid:-}" && kill -USR1 $splashpid
}

unsplash()
{
    # kill -INT will cause pnmto565fb to restore original VT
    test "${splashpid:-}" && kill -INT $splashpid
    splashpid=;
}

leavesplash()
{
    # kill -TERM will cause pnmto565fb to just die
    test "${splashpid:-}" && kill -TERM $splashpid
    splashpid=;
}

do_shutdown()
{
    # echo would shutdown -h now
    /sbin/shutdown -h now
}

check_battery()
{
    read capacity < $CAPACITY
    case $capacity in
    [54321])
        splash critical
        do_shutdown
        ;;
    esac
}

cpu_busy()
{
    # TBD
    return 1
}

network_busy()
{
    # TBD
    return 1
}

laptop_idle()
{
    test -f /var/run/inhibit-idle-suspend && return 1
    cpu_busy && return 1
    network_busy && return 1
    return 0
}

set_wlan_power()
{
    # very important not to do extra writes to wlan-enabled --
    # the node is sort of misnamed.  writing a 0 puts the
    # wlan into reset.  writing a 1 puts it into reset, and
    # immediately releases the reset.  so a reset is always
    # involved, even if brief.
    read_wlan_power w
    if [ "$w" != "$1" ]
    then
        test "$w" = 1 && echo WARNING:  blipping wlan-reset
        echo $1 > $WLAN_ENABLED
    fi
}

read_wlan_power()
{
    local x
    read x < $WLAN_ENABLED
    eval $1=\"$x\"
}

runparts()
{
    rc_action=$1
    test $rc_action = "resume" || return

    rc_dir=$RUNPARTSDIR
    test -d $rc_dir || return

    cd $rc_dir

    for s in *[^~]
    do
        case $s in
        '*[^~]') return;;  # s is the literal pattern
        esac

        if [ -x $s ]; then
                echo "Running $s $rc_action" >&2
                ./$s $rc_action || echo "*** $s failed"
        elif [ -f $s ]; then
                echo "Skipping $s (disabled, not executable)" >&2
        else
                if [ -L $s ]; then
                        echo "Removing dangling symlink $s" >&2
                        rm $s
                else
                        echo "Skipping $s (not an executable file)" >&2
                fi
        fi
    done

}

slumber()
{
    set_wakeupevents none
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WAN" || set_wlan_power 0
    echo 1   >/sys/devices/platform/dcon/sleep 
    echo mem >/sys/power/state
    selfinject useractive2
    set_wakeupevents all
    echo 0   >/sys/devices/platform/dcon/sleep 
    set_wlan_power $wlp
    unsplash
    reevaluate
    set_idletimes
}

set_wakeupevents()
{
    case $1 in
    # setting "all" to 1/0 sets/clears everything else at once,
    # i.e.,  ac_power battery_error battery_soc battery_state 
    #       ebook_mode_change ps2event wlan"
    all)
        echo 1 >$WAKEUP_EVENTS/all
        echo 0 >$WAKEUP_EVENTS/battery_soc
        echo 0 >$WAKEUP_EVENTS/battery_state
        echo 0 >$WAKEUP_EVENTS/ac_power
        ;;
    none)
        echo 0 >$WAKEUP_EVENTS/all
        ;;
    esac
}

read_wakeupsource()
{
    local x
    read x < $WAKEUP_SOURCE
    eval $1=\"$x\"
}

catnap()
{
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WAN" || set_wlan_power 0
    while :
    do
        echo mem >/sys/power/state
        read_wakeupsource wakeupsource
        : wakeupsource is $wakeupsource
        case $wakeupsource in
        "power button")
            selfinject power $(date +%s)
            break
            ;;

        "wlan packet")
            if yes_or_true "$config_MESH_or_WAKE_ON_WAN"
            then
                selfinject useractive2
                break
            fi
            ;;
        *)   #"lid"|"empty sci"|"key press"|"ebook")
            selfinject useractive2
            break
            ;;
        esac
    done
    set_wlan_power $wlp
    set_idletimes
}

set_brightness()
{
    echo $1 >$BRIGHTNESS
}

read_brightness()
{
    local x
    read x < $BRIGHTNESS
    eval $1=\"$x\"
}

brightness_ramp()
{
    local i
    test $1 = $2 && return

    # ramp in either direction
    incr=1
    test $1 -gt $2 && incr=-1

    i=$1
    while :
    do
        let i=i+$incr
        set_brightness $i
        test $i = $2 && break
        usleep 20000
    done
}

backlight()
{
    case $1 in
    restore)
        if [ "$dimmed" -a "$savebright" ]
        then
            read_brightness curbright
            if [ $curbright -lt $savebright ]
            then
                # could ramp here, but it wastes time while
                # the user is starting to work again
                set_brightness $savebright
            fi
            dimmed=;
        fi
        ;;
    dim)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            if [ $savebright -gt $config_IDLEDIM ]
            then
                brightness_ramp $savebright $config_IDLEDIM
            fi
            dimmed=true
        fi
        ;;
    off)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            set_brightness 0
            dimmed=true
        fi
        ;;
    esac
}

default_config()
{
    # give all config values defaults, so we'll
    # never find them unset
    config_EBOOK_IDLETIMES="10 15 240"
    config_IDLETIMES="120 130 240"
    config_IDLEDIM=5
    config_SOLAR=no
    config_ALWAYSON=no
    config_MESH_or_WAKE_ON_WAN=yes
    config_CONFIRM_SECONDS=7
} 

read_config()
{

    source $CONFIGFILE

}

check_acstate()
{
    read on_ac < $AC_ONLINE
    if [ "$on_ac" = 1 ]
    then
        savepower=;
        yes_or_true ${config_SOLAR} && savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    else
        savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    fi
}

set_idletimes()
{
    if [ "$am_ebook" ]
    then
            idletimes=${config_EBOOK_IDLETIMES}
    else
            idletimes=${config_IDLETIMES}
    fi
    if [ "${1:-}" != ifchanged -o "$idletimes" != "${last_idletimes}" ]
    then
        echo "I $idletimes" >$USER_ACTIVITY_CMDS
    fi
    last_idletimes="$idletimes"
}

reevaluate()
{
    check_acstate
}

selfinject()
{
    echo $* >$FIFO
}

sched_timer()
{
    # we can't cancel timers, so give them sequence numbers
    let timerseqno=timerseqno+1
    (sleep $1; shift 1; selfinject timerdone $timerseqno $*) &
}

invalidate_timer()
{
    # bump the seq number so we won't match a scheduled timer
    # when it arrives.
    let timerseqno=timerseqno+1
}

dcon_freeze()
{
    echo $1 > /sys/devices/platform/dcon/freeze
}

gotactivity()
{
    am_idle=;
    lastpowerpress=0  #invalidate outstanding power button timer
    invalidate_timer  # and invalidate timerdone messages
    unsplash
}

check_first_activity()
{
    # this is a bit of a hack.  on the XO, the bootanim
    # script contrives to leave the dcon frozen at the end
    # of the init sequence.  it remains frozen until sugar
    # first becomes idle, at which point sugar sends a dbus
    # message to ohmd, causing ohmd to unfreeze the dcon.
    # since we don't do dbus, we unfreeze the dcon after
    # a) 10 seconds have passed since we started, or b)
    # user activity is detected.
    if [ "$initial_freeze" ]
    then
        dcon_freeze 0
        initial_freeze=;
    fi
}

event_loop()
{
    local event arg1 arg2 more

    idletimes=${config_IDLETIMES:-"120 130 240"}

    #set -x
    #exec 2>>$LOGFILE
    : starting eventloop

    check_acstate
    set_idletimes

    trap "unsplash; exit" 1 2 3 15
    unsplash

    # recreate to flush, and to make sure it's a fifo
    rm -f $FIFO
    mkfifo $FIFO

    while :
    do
        set_idletimes ifchanged

        if ! read -t 10 event arg1 arg2 more
        then
            event=timeout
            arg1=; arg2=; more=;
        fi

        : -------------------------
        : got $event, arg1: ${arg1:-n/a} arg2: ${arg2:-n/a}

        case $event in

        power)
            am_idle=;
            now=$arg1
            let delta=$now-$lastpowerpress
            if [ $delta -ge $config_CONFIRM_SECONDS  ]
            then # first press
                splash confirm
                set_idletimes   # reprime for "useractivity"
                sched_timer $config_CONFIRM_SECONDS gotosleep
                backlight restore
            else # second press
                nextsplash  # advance to next splash screen
                sleep 1
                do_shutdown &
                leavesplash # kill the splasher (leaving splash visible)
                sleep 9999999
            fi
            lastpowerpress=$now
            ;;

        timerdone)
            # are we still waiting for this timer?
            if [ "$timerseqno" = "$arg1" ]
            then
                echo $arg2 >$FIFO
            fi
            ;;

        lidclose|gotosleep)
            gotactivity
            backlight off
            slumber
            runparts resume &
            ;;

        lidopen)
            gotactivity
            backlight restore
            ;;

        ebookclose)
            am_idle=;
            am_ebook=true
            ;;

        ebookopen)
            am_idle=;
            am_ebook=;
            ;;

        useractive*)
            gotactivity
            backlight restore
            test "$event" = useractive2 && set_idletimes
            check_first_activity
            ;;

        useridle1)
            am_idle=1
            if [ "$savepower" -a ! "$am_ebook" ]
            then
                backlight dim
            fi
            ;;

        useridle2)
            am_idle=2
            if [ "$savepower" ] && laptop_idle
            then
                catnap
                runparts resume &
            fi
            ;;

        useridle3)
            am_idle=3
            ;;

        timeout)
            osavepower=$savepower
            check_battery
            check_acstate
            if [ "$savepower" -a ! "$osavepower" ]
            then
                # this will force a restart of the timers,
                # so we'll go through the useridle1/2 cycle again
                set_idletimes
            fi
            check_first_activity
            ;;

        reconfig)
            read_config
            ;;

        esac
    done <> $FIFO
}


default_config
read_config
am_ebook=;
dimmed=;
savebright=;
last_idletimes=;
timerseqno=0;
lastpowerpress=0;

initial_freeze=true

set_wakeupevents all

event_loop

