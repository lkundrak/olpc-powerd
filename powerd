#!/bin/sh
#
# powerd -- experimental power management for the XO
# 
# this daemon is a more transparent and flexible (if
# incompatible, and perhaps less robust!) replacement for ohmd on
# the XO.  powerd is independent of X, dbus, and hald, and so
# might be attractive to very lightweight software distributions.
#
# in addition to "standard" XO/ohmd functionality, powerd adds:
# -- a power button splash screen (allowing cancel, suspend, or shutdown).
# -- the ability to run arbitrary scripts after a resume.
# -- configurable timeouts until screen dim and sleep, and configurable
#    dim level.
# -- different power management behavior when on wall power vs. battery.
# -- different behavior when in ebook mode (though detection may be unreliable)
# -- ease of customization, given that its written in shell.
#
# unimplemented:
# -- inhibiting idle suspend based on system or network load.
# -- any special support for the mesh, whatsoever.
# -- there's some support for wake-on-lan, but it's not well tested.
# -- probably more.
#
# major config variables are documented in powerd.conf.  powerd reads
# its configuration from /etc/powerd/powerd.conf once at startup,
# and again only when it receives a "reconfig" event on its
# event fifo (/var/run/powerevents).
#
# idle suspend can be manually inhibited by creating the file
#    /var/run/inhibit-idle-suspend
#
# post-resume scripts can be put in /etc/powerd/postresume.d -- the
# scripts will be run in lexicographic order.  the scripts are
# run detached from powerd, so they won't impede its operation -- however,
# they should be kept as short as possible.
#
# the inputs that contribute to power management are:
#
# ** switches:
#       power button
#       ebook
#       lid
# actions on these switches appear as events on
# /dev/input/event[012].  powerd relies on the companion
# program "olpc-switchd" to report these events via the
# /var/run/powerevents fifo it creates for the purpose.  it's
# unfortunate that these events have no corresponding /sys state
# indicators, since knowing the state of the lid, or of ebook
# mode, would be useful in the absence of events (at startup, for
# instance).  in addition, it seems that the ebook switch may
# suffer from the lid switch symptoms described in
# http://dev.laptop.org/ticket/5703 .  the lid switch events seem
# to be reliable (but see below re:  wakeup source reporting).
#
# ** conditions:
#       AC input (boolean)
#       battery level (numeric)
# it's unfortunate that these have no corresponding events, since
# otherwise no polling would be necessary.
#
# ** wakeups:
#       ac_power
#       battery_error
#       battery_soc
#       battery_state
#       ebook_mode_change
#       ps2event
#       wlan
#       lid (or sometimes "empty sci")
# when the system wakes from sleep, /sys/power/wakeup-source reports
# the cause.  lid reporting is not reliable -- sometimes "empty sci"
# is reported instead.  (i've not yet seen a case where "empty sci"
# is reported for lid close, or for ebook_mode_change, but i'm not
# ruling it out.)
#
# ** user activity/idleness:
# powerd expects user activity and user idle events to be delivered via
# the olpc-kbdshim daemon, when invoked with "-A /var/run/powerevents".
# the possible events are:
#       useractivity
#       useridle1
#       useridle2
#       useridle3
#
# these events are used in the following ways:
#
#                  screen          cpu
#                  ------          ---
#     useridle1     dim            on
#     useridle2     dim            sleep
#     rtcwake1      off            sleep
#     rtcwake2           shutdown
#
# or, if $config_DARK_BEFORE_SLEEP is set true, this sequence,
# which is more like a "normal" laptop behaves:
#
#                  screen          cpu
#                  ------          ---
#     useridle1     dim            on
#     useridle2     off            on
#     useridle3     off            sleep
#     rtcwake2           shutdown
#
#
#
# ** other system activity (cpu load, network load, etc):
#       unimplemented
#
# note that X11 DPMS is neither consulted nor configured, and it
# may still be used to blank the display after some period of
# inactivity.  (this won't happen, of course, unless the DPMS
# "standby" time is shorter than powerd's "useridle2" time.
#
# my intention is that this be runnable with most any shell.  no
# bash-specific features were used, unless by accident.
#
# -----------------------------------------------
#
# Copyright (C) 2009, Paul G Fox
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
# USA.
#

PROJECTDIR=/etc/powerd
RUNPARTSDIR=/etc/powerd/postresume.d

CONFIGFILE=$PROJECTDIR/powerd.conf
LOGFILE=$PROJECTDIR/powerd.log   # only used for debug, currently

CONFIRMSPLASH=$PROJECTDIR/pleaseconfirm.pgm
SHUTSPLASH=$PROJECTDIR/shuttingdown.pgm
BATTSHUTSPLASH=$PROJECTDIR/shuttingdown.pgm

FIFO=/var/run/powerevents

# note re: battery capacity:
# i'd use /sys/.../capacity_level here, but we never hit
# "critical" -- we only get to "low", which then lasts for
# another half hour.  using /sys/.../capacity (which gives a
# percentage), and cutting off at 5% means we're shutting down
# with (on my machine and battery under 2 minutes of runtime
# left.  close enough for jazz...
CAPACITY=/sys/class/power_supply/olpc-battery/capacity  # percentage

AC_ONLINE=/sys/class/power_supply/olpc-ac/online  # 1/0
BRIGHTNESS=/sys/class/backlight/dcon-bl/brightness  # 0-15
WLAN_ENABLED=/sys/power/wlan-enabled # 1/0 (see comment at set_wlan_power())

WAKEUP_EVENTS=/sys/power/wakeup_events # directory of mask bits
WAKEUP_SOURCE=/sys/power/wakeup-source # contains name of last wakeup source.

DCON_FREEZE=/sys/devices/platform/dcon/freeze
DCON_SLEEP=/sys/class/backlight/dcon-bl/device/sleep

# command fifo for olpc-kbdshim
USER_ACTIVITY_CMDS=/var/run/olpc-kbdshim_command


set -u

log()
{
    logger -t powerd -p daemon.info -- "$@"
}

yes_or_true()
{
    case $1 in
    [yYtT]*) return 0 ;;
    esac

    return 1
}

splash()
{
    case $1 in
    confirm)
        args="$CONFIRMSPLASH $SHUTSPLASH"
        ;;
    critical)
        args="$BATTSHUTSPLASH"
        ;;
    esac

    pnmto565fb -d -s 9999999 $args &
    splashpid=$!
}

nextsplash()
{
    # kill -USR1 will cause pnmto565fb to display next image
    test "${splashpid:-}" && kill -USR1 $splashpid
}

unsplash()
{
    # kill -INT will cause pnmto565fb to restore original VT
    test "${splashpid:-}" && kill -INT $splashpid
    splashpid=;
}

leavesplash()
{
    # kill -TERM will cause pnmto565fb to just die
    test "${splashpid:-}" && kill -TERM $splashpid
    splashpid=;
}

do_shutdown()
{
    log shutting down due to $*
    /sbin/shutdown -h now &
    leavesplash # kill the splasher (leaving splash visible)
    sleep 9999999
}

check_battery()
{
    read capacity < $CAPACITY
    case $capacity in
    [54321])   # 5% or less
        splash critical
        sleep 1
        do_shutdown "low battery"
        ;;
    esac
}

cpu_busy()
{
    # TBD
    return 1
}

network_busy()
{
    # TBD
    return 1
}

laptop_idle()
{
    test -f /var/run/inhibit-idle-suspend && return 1
    cpu_busy && return 1
    network_busy && return 1
    return 0
}

set_wlan_power()
{
    # very important not to do extra writes to wlan-enabled --
    # the node is sort of misnamed.  writing a 0 puts the
    # wlan into reset.  writing a 1 puts it into reset, and
    # immediately releases the reset.  so a reset is always
    # involved, even if brief.
    read_wlan_power w
    if [ "$w" != "$1" ]
    then
        test "$w" = 1 && echo WARNING:  blipping wlan-reset
        echo $1 > $WLAN_ENABLED
    fi
}

read_wlan_power()
{
    local x
    read x < $WLAN_ENABLED
    eval $1=\"$x\"
}

runparts()
{
    rc_action=$1
    test $rc_action = "resume" || return

    rc_dir=$RUNPARTSDIR
    test -d $rc_dir || return

    cd $rc_dir

    for s in *[^~]
    do
        case $s in
        '*[^~]') return;;  # s is the literal pattern
        esac

        if [ -x $s ]; then
                echo "Running $s $rc_action" >&2
                ./$s $rc_action || echo "*** $s failed"
        elif [ -f $s ]; then
                echo "Skipping $s (disabled, not executable)" >&2
        else
                if [ -L $s ]; then
                        echo "Removing dangling symlink $s" >&2
                        rm $s
                else
                        echo "Skipping $s (not an executable file)" >&2
                fi
        fi
    done

}

slumber()
{
    set_wakeupevents none
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WLAN" || set_wlan_power 0
    dcon sleep
    echo mem >/sys/power/state
    selfinject fake_useractive
    set_wakeupevents all
    dcon wake
    set_wlan_power $wlp
    unsplash
    reset_idlecounter
}

set_wakeupevents()
{
    case $1 in
    # setting "all" to 1/0 sets/clears everything else at once,
    # i.e.,  ac_power battery_error battery_soc battery_state 
    #       ebook_mode_change ps2event wlan"
    all)
        echo 1 >$WAKEUP_EVENTS/all
        echo 0 >$WAKEUP_EVENTS/battery_soc
        echo 0 >$WAKEUP_EVENTS/battery_state
        echo 0 >$WAKEUP_EVENTS/ac_power
        ;;
    none)
        echo 0 >$WAKEUP_EVENTS/all
        ;;
    esac
}

read_wakeupsource()
{
    local x
    read x < $WAKEUP_SOURCE
    eval $1=\"$x\"
}

catnap()
{
    read_wlan_power wlp
    yes_or_true "$config_MESH_or_WAKE_ON_WLAN" || set_wlan_power 0

    # we only use rtc alarms to either a) turn of the screen when
    # we've been sleeping for a while, or b) shutdown after we've
    # been sleeping for a while.  if we do a), we'll do b) next.
    if [ "$1" = "rtc" ]
    then
        rtctype=$2   # "screenoff", or "shutdown"
        rtctime=$3
    else
        rtctype=;
    fi

    while :
    do
        if [ "$rtctype" ]
        then
            rtcwake -m mem -a -s $rtctime
        else
            echo mem >/sys/power/state
        fi
        read_wakeupsource wakeupsource
        : wakeupsource is $wakeupsource
        case $wakeupsource in
        "power button")
            selfinject power $(date +%s)
            break
            ;;

        "wlan packet")
            if yes_or_true "$config_MESH_or_WAKE_ON_WLAN"
            then
                selfinject fake_useractive
                break
            fi
            ;;
        "rtc alarm")
            case $rtctype in
            screenoff)
                backlight off
                rtctype=shutdown
                rtctime=$4
                ;;
            shutdown)
                do_shutdown "idle timeout"
                ;;
            *) # it's a leftover (spurious?) rtc wakeup.  go back to sleep.
                ;;
            esac
            ;;
        *)   # "lid"|"empty sci"|"key press"|"ebook")
            selfinject fake_useractive
            break
            ;;
        esac
    done
    set_wlan_power $wlp
    reset_idlecounter
}

set_brightness()
{
    echo $1 >$BRIGHTNESS
}

read_brightness()
{
    local x
    read x < $BRIGHTNESS
    eval $1=\"$x\"
}

brightness_ramp()
{
    local i
    test $1 = $2 && return

    # ramp in either direction
    incr=1
    test $1 -gt $2 && incr=-1

    i=$1
    while :
    do
        : $((i += incr))
        set_brightness $i
        test $i = $2 && break
        usleep 20000
    done
}

backlight()
{
    case $1 in
    restore)
        dcon wake
        if [ "$dimmed" -a "$savebright" ]
        then
            read_brightness curbright
            if [ $curbright -lt $savebright ]
            then
                # could ramp here, but it wastes time while
                # the user is starting to work again
                set_brightness $savebright
            fi
            dimmed=;
        fi
        ;;
    dim)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            if [ $savebright -gt $config_IDLEDIM ]
            then
                brightness_ramp $savebright $config_IDLEDIM
            fi
            dimmed=true
        fi
        ;;
    off)
        if [ ! "${dimmed}" ]
        then
            read_brightness savebright
            set_brightness 0
            dimmed=true
        fi
        dcon sleep
        ;;
    esac
}

default_config()
{
    # give all config values defaults, so we'll
    # never find them unset
    config_EBOOK_IDLETIMES="10 15 240 1800"
    config_IDLETIMES="120 130 240 3600"
    config_IDLEDIM=5
    config_SOLAR=no
    config_ALWAYSON=no
    config_MESH_or_WAKE_ON_WLAN=yes
    config_CONFIRM_SECONDS=7
    config_DARK_BEFORE_SLEEP=false
} 

read_config()
{
    source $CONFIGFILE
    if yes_or_true $config_ALWAYSON
    then
	log configured for always on
    elif yes_or_true $config_SOLAR
    then
	log configured to save power even on external source
    else
	log configured for power saving on battery only
    fi
}

check_acstate()
{
    read on_ac < $AC_ONLINE
    if [ "$on_ac" = 1 ]
    then
        savepower=;
        yes_or_true ${config_SOLAR} && savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    else
        savepower=true;
        yes_or_true ${config_ALWAYSON} && savepower=;
    fi
    # return success if on external power
    test $on_ac = 1
}

reset_idlecounter()
{
    # olpc-kbdshim will reset its idle timers when the deadlines are reset
    echo "I $t1 $t2 $t3" >$USER_ACTIVITY_CMDS
}

set_idletimes()
{
    if [ "$am_ebook" ]
    then
            idletimes=${config_EBOOK_IDLETIMES}
    else
            idletimes=${config_IDLETIMES}
    fi

    if [ "$idletimes" = "${last_idletimes}" ]
    then
        return
    fi

    set -- ${idletimes}

    # validate the given times, and turn them into deltas.
    t1=${1:-120}
    t2=${2:-0}
    t3=${3:-0}
    t4=${4:-0}
    test "$t1" -eq "$t1" || t1=120   # force numeric

    #if any delta is 0 or negative, make it 60
    #if any delta is less than 5, make it at least 5
    test ! "$t2" -o "$t2" -le "$t1" && t2=$((t1 + 60))
    test "$t2" -le $((t1 + 5)) && t2=$((t1 + 5))

    test ! "$t3" -o "$t3" -le "$t2" && t3=$((t2 + 60))
    test "$t3" -le $((t2 + 5)) && t3=$((t2 + 5))

    test ! "$t4" -o "$t4" -le "$t3" && t4=$((t3 + 600))
    test "$t4" -le $((t3 + 5)) && t4=$((t3 + 5))
    
    # give olpc-kbdshim the timeouts
    echo "I $t1 $t2 $t3" >$USER_ACTIVITY_CMDS

    if yes_or_true "$config_DARK_BEFORE_SLEEP"
    then
        screenofftimer=;
        shutdowntimer=$((t4 - t3))
        log dim in $t1 seconds, blank in $t2, sleep in $t3, shutdown in $t4
    else
        screenofftimer=$((t3 - t2))
        shutdowntimer=$((t4 - t3))
        log dim in $t1 seconds, sleep in $t2, blank in $t3, shutdown in $t4
    fi

    last_idletimes="$idletimes"
}

reevaluate()
{
    check_acstate || check_battery
    if [ "${o_savepower:-}" != "$savepower" -o \
         "${o_ebook:-}" != "$am_ebook" ]
    then
        set_idletimes
        reset_idlecounter
    fi
    o_ebook=$am_ebook
    o_savepower=$savepower
}

selfinject()
{
    echo $* >$FIFO
}

sched_timer()
{
    # we can't cancel timers, so give them sequence numbers
    : $((timerseqno += 1))
    (sleep $1; shift 1; selfinject timerdone $timerseqno $*) &
}

invalidate_timer()
{
    # bump the seq number so we won't match a scheduled timer
    # when it arrives.
    : $((timerseqno += 1))
}

dcon()
{
    case $1 in
    freeze) echo 1 > $DCON_FREEZE ;;
    thaw)   echo 0 > $DCON_FREEZE ;;
    sleep)  echo 1 > $DCON_SLEEP ;;
    wake)   echo 0 > $DCON_SLEEP ;;
    esac
}

gotactivity()
{
    invalidate_timer  # invalidate timerdone messages
    unsplash
}

check_first_activity()
{
    # this is a bit of a hack.  on the XO, the bootanim
    # script contrives to leave the dcon frozen at the end
    # of the init sequence.  it remains frozen until sugar
    # first becomes idle, at which point sugar sends a dbus
    # message to ohmd, causing ohmd to unfreeze the dcon.
    # since we don't do dbus, we unfreeze the dcon after
    # a) 10 seconds have passed since we started, or b)
    # user activity is detected.
    if [ "$initial_freeze" ]
    then
        dcon thaw
        initial_freeze=;
    fi
}

event_loop()
{
    local event arg1 arg2 more

    idletimes=$config_IDLETIMES

    set -x
    exec 2>$LOGFILE
    : starting eventloop

    check_acstate
    set_idletimes

    trap "unsplash; exit" 1 2 3 15
    unsplash

    # recreate to flush, and to make sure it's a fifo
    rm -f $FIFO
    mkfifo $FIFO

    while :
    do
        reevaluate

        if ! read -t 10 event arg1 arg2 more
        then
            event=timeout
            arg1=; arg2=; more=;
        fi

        : -------------------------
        : got "<$event>", arg1: ${arg1:-n/a} arg2: ${arg2:-n/a}

        case $event in

        power)
            if [ "$powerseqno" != "$timerseqno" ]
            then # first press
                splash confirm
                reset_idlecounter # reprime for "useractivity"
                sched_timer $config_CONFIRM_SECONDS gotosleep
                powerseqno=$timerseqno
                backlight restore
            else # second press
                nextsplash  # advance to next splash screen
                sleep 1
                do_shutdown  "power press"
            fi
            ;;

        timerdone)
            # are we still waiting for this timer?
            if [ "$timerseqno" = "$arg1" ]
            then
                echo $arg2 >$FIFO
                : $((timerseqno += 1))
            fi
            ;;

        lidclose|gotosleep)
            gotactivity
            backlight off
            slumber
            runparts resume &
            ;;

        lidopen)
            gotactivity
            backlight restore
            ;;

        ebookclose)
            am_ebook=true
            ;;

        ebookopen)
            am_ebook=;
            ;;

        useractive|fake_useractive)
            gotactivity
            backlight restore
            test "$event" = fake_useractive && reset_idlecounter
            check_first_activity
            ;;

        useridle1)
            if [ "$savepower" -a ! "$am_ebook" ]
            then
                backlight dim
            fi
            ;;

        useridle2)
            if [ "$savepower" ] && laptop_idle
            then
                if yes_or_true "$config_DARK_BEFORE_SLEEP"
                then
                    backlight off
                else
                    catnap rtc screenoff "$screenofftimer" "$shutdowntimer"
                    runparts resume &
                fi
            fi
            ;;

        useridle3)
            if [ "$savepower" ] && laptop_idle
            then
                if yes_or_true "$config_DARK_BEFORE_SLEEP"
                then
                    # schedule a wakeup, so we can shut down
                    catnap rtc shutdown "$shutdowntimer"
                    runparts resume &
                #else
                #    ; # shouldn't happen
                fi
            fi
            ;;

        timeout)
            check_first_activity
            ;;

        reconfig)
            read_config
            ;;

        esac
    done <> $FIFO
}

log starting

default_config
read_config

am_ebook=;
o_ebook=xxx;
o_savepower=xxx;
dimmed=;
savebright=;
last_idletimes=;
timerseqno=1;
powerseqno=0;

initial_freeze=true

set_wakeupevents all

event_loop

